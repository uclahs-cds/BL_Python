"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, List, Mapping, MutableMapping, Optional, Set, Tuple, Type, TypeVar, overload

if True:
    ...
EMPTY_DICT: Mapping[Any, Any] = ...
_T = TypeVar("_T", bound=Any)
_C = TypeVar("_C", bound=Callable[..., Any])
class _ModuleClsMeta(type):
    def __setattr__(cls, key: str, value: Callable[..., Any]) -> None:
        ...
    


class ModuleClsProxy(metaclass=_ModuleClsMeta):
    """Create module level proxy functions for the
    methods on a given class.

    The functions will have a compatible signature
    as the methods.

    """
    _setups: Dict[Type[Any], Tuple[Set[str], List[Tuple[MutableMapping[str, Any], MutableMapping[str, Any]]],],] = ...
    @classmethod
    def create_module_class_proxy(cls, globals_: MutableMapping[str, Any], locals_: MutableMapping[str, Any]) -> None:
        ...
    


def rev_id() -> str:
    ...

@overload
def to_tuple(x: Any, default: Tuple[Any, ...]) -> Tuple[Any, ...]:
    ...

@overload
def to_tuple(x: None, default: Optional[_T] = ...) -> _T:
    ...

@overload
def to_tuple(x: Any, default: Optional[Tuple[Any, ...]] = ...) -> Tuple[Any, ...]:
    ...

def to_tuple(x: Any, default: Optional[Tuple[Any, ...]] = ...) -> Optional[Tuple[Any, ...]]:
    ...

def dedupe_tuple(tup: Tuple[str, ...]) -> Tuple[str, ...]:
    ...

class Dispatcher:
    def __init__(self, uselist: bool = ...) -> None:
        ...
    
    def dispatch_for(self, target: Any, qualifier: str = ...) -> Callable[[_C], _C]:
        ...
    
    def dispatch(self, obj: Any, qualifier: str = ...) -> Any:
        ...
    
    def branch(self) -> Dispatcher:
        """Return a copy of this dispatcher that is independently
        writable."""
        ...
    


def not_none(value: Optional[_T]) -> _T:
    ...

